<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on A Better Tomorrow</title><link>https://j2e4.github.io/post/</link><description>Recent content in Posts on A Better Tomorrow</description><generator>Hugo</generator><language>ko-KR</language><lastBuildDate>Sat, 12 Oct 2024 01:11:56 +0900</lastBuildDate><atom:link href="https://j2e4.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>생각을 표현하는 코드를 쓰고, 읽고 싶어요.</title><link>https://j2e4.github.io/post/self-expression-in-code/</link><pubDate>Fri, 23 Feb 2024 21:51:24 +0900</pubDate><guid>https://j2e4.github.io/post/self-expression-in-code/</guid><description>&lt;p>종종 의도를 파악하기 어려운 코드를 만나 의욕이 떨어지는 경험을 합니다.
생각나는 경우를 조금 적어볼게요.&lt;/p>
&lt;ul>
&lt;li>조건문, 반복문을 무분별하게 사용해 코드의 길이가 길고 깊이가 깊은 코드&lt;/li>
&lt;li>코드의 재사용을 어렵게 하는 불필요한 하드 코딩&lt;/li>
&lt;li>라이브러리나 프레임워크의 권장 사항을 따르지 않거나 로직을 복잡하게 만드는 코딩 패턴&lt;/li>
&lt;/ul>
&lt;p>“충분한 고민, 생각을 거쳐 코딩한 걸까?” 생각했을 때 제 맘대로 “그렇지 않다.”라고 단언할 수는 없습니다.&lt;br>
모든 코드를 제가 쓴 게 아니기 때문이에요.&lt;br>
그리고 제가 이해하기 어렵다고 무조건 틀렸다고 얘기할 수 있는 것도 아닙니다.&lt;/p></description></item><item><title>React와 JSX, 조금 더 알아보기</title><link>https://j2e4.github.io/post/react-jsx/</link><pubDate>Mon, 16 Oct 2023 20:00:12 +0900</pubDate><guid>https://j2e4.github.io/post/react-jsx/</guid><description>&lt;p>JSX는 자바스크립트의 문법을 확장해 자바스크립트 파일에서 마크업을 작성할 수 있게 해주는 언어입니다.&lt;br>
JSX로 작성한 자바스크립트 파일은 HTML 파일과 비슷한 모양을 갖게 돼요.&lt;/p>
&lt;h3 id="jsx-왜-쓰나요">JSX, 왜 쓰나요?&lt;/h3>
&lt;p>HTML, JavaScript 각각 작성하면 될 텐데 굳이 왜 JSX를 쓰는 걸까요?&lt;/p>
&lt;p>HTML과 JavaScript는 계속해서 더 가까워지고 있어요. 웹의 인터랙티브 요소가 많아지면서 이벤트 핸들러를 구현할 일이 많아졌고 HTML 내용을 JavaScript에서 채우는 일 또한 많아졌습니다.&lt;br>
HTML과 JavaScript를 따로따로 코딩하는 것보다 그룹으로 묶어 코딩하는 게 더 쉬울 거예요.&lt;br>
그래서 JSX로 HTML 코드와 JavaScript 코드를 함께 작성합니다.&lt;/p></description></item><item><title>Debounce, 마지막 이벤트만 처리하기 (cf. Throttle)</title><link>https://j2e4.github.io/post/debounce/</link><pubDate>Thu, 02 Mar 2023 00:21:36 +0900</pubDate><guid>https://j2e4.github.io/post/debounce/</guid><description>&lt;p>디바운스는 동일한 이벤트가 연달아 발생할 때 &lt;strong>마지막 이벤트를 감지해 처리&lt;/strong>하는 이벤트 처리 방식이에요.&lt;br>
마지막 이벤트가 발생하고 개발자가 지정한 시간 이후에 Callback을 실행합니다.&lt;/p>
&lt;p>디바운스를 구현하는 방법은 이벤트가 발생할 때마다 새로운 타이머를 설정해주면 돼요.&lt;br>
그러다 어느 순간부터 이벤트가 발생하지 않으면 새로운 타이머를 설정하지 않을 거에요.&lt;br>
그럼 마지막 이벤트가 설정한 타이머에 의해 Callback을 실행하게 됩니다.&lt;/p>
&lt;p>저는 resize 이벤트를 핸들링하는 로직, 사용자 입력에 실시간으로 반응할 필요가 없는 동작을 구현할 때 디바운스를 종종 사용해요.&lt;br>
예를 들어 &lt;code>&amp;lt;input /&amp;gt;&lt;/code> 입력 필드에 사용자가 입력한 값이 validation 조건에 맞지 않는 경우 힌트 메시지를 보여줘야 한다고 해볼께요.&lt;br>
만약 사용자가 아직 입력 중이라면 힌트 메시지를 바로 보여주지 않아도 괜찮습니다.&lt;br>
이런 경우 디바운스로 핸들링 로직을 감싸 lazy하게 반응하도록 의도할 수 있어요.&lt;/p></description></item><item><title>Vue CLI의 Babel 플러그인을 최신 버전으로 업그레이드하기</title><link>https://j2e4.github.io/post/update-babel-in-vue-two/</link><pubDate>Thu, 16 Feb 2023 00:21:53 +0900</pubDate><guid>https://j2e4.github.io/post/update-babel-in-vue-two/</guid><description>&lt;blockquote>
&lt;p>&lt;em>Vue CLI는 Vue 2를 위한 도구입니다.&lt;br>
본 포스팅은 Vue 2 기반의 프로젝트에서 진행한 내용임을 알려드립니다.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>Vue.js는 &lt;a href="https://cli.vuejs.org/core-plugins/babel.html">@vue/cli-plugin-babel&lt;/a>을 코어 플러그인으로 사용합니다.&lt;br>
Vue.js 코드를 브라우저가 이해할 수 있는 JavaScript 코드로 트랜스파일하기 위해 &lt;a href="https://babeljs.io/docs/">Babel&lt;/a>을 활용하죠.&lt;/p>
&lt;p>참고로 저는 프로젝트 코드에서 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">옵셔널 체이닝(Optional chaining)&lt;/a>을 사용하기 위해 관련 내용을 알아보기 시작했어요.&lt;br>
만약 저와 같은 목적을 갖고 계시면서 사이드 이펙트 걱정이 크신 분이시라면 &lt;a href="https://babeljs.io/docs/babel-plugin-proposal-optional-chaining#installation">공식 문서&lt;/a>에서 안내하는 대로 필요한 의존성만 추가해줘도 괜찮습니다.&lt;br>
하지만 해당 플러그인을 포함하는 버전으로 업그레이드해 넓은 범위의 해결을 추구하는 것이 좋지 않을까하는 개인적인 의견을 덧붙이며, 시작하겠습니다.&lt;/p></description></item></channel></rss>