<!doctype html><html lang=ko-KR><head><title>하나의 CloudFront 도메인으로 두 개의 S3 엔드포인트 호스팅하기 // A Better Tomorrow</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.121.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jainee"><meta name=description content><link rel=stylesheet href=/css/main.min.1611cbf3fc8de624ffc2a2d3759804fe4851a18da6177d56198e063df4e10cd6.css><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-WDCLQCSP")</script><meta name=twitter:card content="summary"><meta name=twitter:title content="하나의 CloudFront 도메인으로 두 개의 S3 엔드포인트 호스팅하기"><meta name=twitter:description content="아래와 같이 Vue.js로 구현한 애플리케이션과 Next.js로 구현한 애플리케이션을 하나의 도메인으로 호스팅하기 위해 아마존의 CDN 서비스, Amazon CloudFront를 활용한 경험을 공유한다.
이하 각 서비스를 &ldquo;이름&rdquo; 칼럼에 적어둔 값으로 부를 예정이다.
S3 엔드포인트 이름 프레임워크 목적 AS-IS 도메인 경로 TO-BE 도메인 경로 1 서비스 애플리케이션 Vue.js 사용자에게 서비스를 제공 /를 포함한 메뉴별 경로 /를 포함하지 않는 메뉴별 경로 2 랜딩 페이지 Next.js 서비스로 사용자 유입을 도모 / / 아래 그림은 요청 경로에 따라 CloudFront가 요청을 보내는 원본이 어디인지 표현한 그림이다."><meta property="og:title" content="하나의 CloudFront 도메인으로 두 개의 S3 엔드포인트 호스팅하기"><meta property="og:description" content="아래와 같이 Vue.js로 구현한 애플리케이션과 Next.js로 구현한 애플리케이션을 하나의 도메인으로 호스팅하기 위해 아마존의 CDN 서비스, Amazon CloudFront를 활용한 경험을 공유한다.
이하 각 서비스를 &ldquo;이름&rdquo; 칼럼에 적어둔 값으로 부를 예정이다.
S3 엔드포인트 이름 프레임워크 목적 AS-IS 도메인 경로 TO-BE 도메인 경로 1 서비스 애플리케이션 Vue.js 사용자에게 서비스를 제공 /를 포함한 메뉴별 경로 /를 포함하지 않는 메뉴별 경로 2 랜딩 페이지 Next.js 서비스로 사용자 유입을 도모 / / 아래 그림은 요청 경로에 따라 CloudFront가 요청을 보내는 원본이 어디인지 표현한 그림이다."><meta property="og:type" content="article"><meta property="og:url" content="https://j2e4.github.io/post/hosting-websites-under-one-domain/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-09-04T23:32:13+09:00"><meta property="article:modified_time" content="2023-12-11T23:18:23+09:00"></head><body><header class=app-header><a href=https://j2e4.github.io/><img class=app-header-avatar src=/avatar.jpeg alt=Jainee></a>
<span class=app-header-title>A Better Tomorrow</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags>Tags</a></nav><p>오늘보다 내일 더 나은 서비스를 만들기 위해 개발합니다.</p><div class=app-header-social><a href=https://github.com/j2e4 target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://j2e4.tistory.com/ target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-type"><title>Tistory</title><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>하나의 CloudFront 도메인으로 두 개의 S3 엔드포인트 호스팅하기</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Sep 4, 2023
| Dec 11, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://j2e4.github.io/tags/cloudfront/>CloudFront</a>
<a class=tag href=https://j2e4.github.io/tags/s3/>S3</a></div></div></header><div class=post-content><p>아래와 같이 Vue.js로 구현한 애플리케이션과 Next.js로 구현한 애플리케이션을 하나의 도메인으로 호스팅하기 위해 아마존의 CDN 서비스, Amazon CloudFront를 활용한 경험을 공유한다.<br>이하 각 서비스를 <strong>&ldquo;이름&rdquo;</strong> 칼럼에 적어둔 값으로 부를 예정이다.</p><table><thead><tr><th>S3 엔드포인트</th><th>이름</th><th>프레임워크</th><th>목적</th><th>AS-IS 도메인 경로</th><th>TO-BE 도메인 경로</th></tr></thead><tbody><tr><td>1</td><td>서비스 애플리케이션</td><td>Vue.js</td><td>사용자에게 서비스를 제공</td><td><code>/</code>를 포함한 메뉴별 경로</td><td><code>/</code>를 포함하지 않는 메뉴별 경로</td></tr><tr><td>2</td><td>랜딩 페이지</td><td>Next.js</td><td>서비스로 사용자 유입을 도모</td><td><code>/</code></td><td><code>/</code></td></tr></tbody></table><p>아래 그림은 요청 경로에 따라 CloudFront가 요청을 보내는 원본이 어디인지 표현한 그림이다.<br><figure class=request-origin><img src=hosting-websites-under-one-domain.png alt="요청 경로에 따라 참조하는 S3 원본"></figure></p><h2 id=amazon-cloudfront를-사용한-이유>Amazon CloudFront를 사용한 이유</h2><p>원하는 바를 이루기 위해 취할 수 있는 여러 방법이 있겠지만, Amazon CloudFront를 사용한 이유는 다음과 같다.</p><ol><li>호스팅 수단으로 이미 Amazon CloudFront를 사용하고 있었다.<br>같은 범주에 두어야 인프라 관리에 용이하다고 생각했다.</li><li>모바일 앱에서 도메인의 루트 경로를 요청해 서비스 애플리케이션의 화면을 웹뷰로 보여주고 있었다. 작업 후에도 모바일 앱에서 요청하는 루트 경로의 도메인은 랜딩 페이지가 아닌 서비스 애플리케이션을 응답해야 한다.<br><a href=https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/example-function-redirect-url.html>이 문서</a>를 참고해 루트 경로를 요청한 주체가 모바일 앱일 경우 리다이렉트를 응답해 요구사항을 만족시킬 수 있겠다고 생각했다.</li></ol><h2 id=진행-과정>진행 과정</h2><ol><li>서비스 애플리케이션 Vue Router에 등록한 <code>/</code> 경로를 적절한 의미의 다른 경로로 수정한다.<ul><li>AS-IS: <code>/</code></li><li>TO-BE: <code>/home</code></li></ul></li><li>랜딩 페이지 코드에서 서비스 애플리케이션으로 이동하는 링크를 수정한다.<ul><li>AS-IS: <code>https://www.example.com</code></li><li>TO-BE: <code>https://www.example.com/home</code></li></ul></li><li>Amazon CloudFront 설정을 진행한다.<ol><li>CloudFront > 사이드바에서 <strong>배포</strong> 선택 > 목록에서 배포 선택<ul><li>사용하고 있던 서비스 애플리케이션의 도메인을 계속 사용할거라 새 배포를 생성하지 않았다.</li></ul></li><li><strong>원본</strong> 탭 > <strong>원본 생성</strong> 버튼 클릭, 랜딩 페이지의 S3 웹사이트 엔드포인트 추가<ul><li>서비스 애플리케이션의 S3 웹사이트 엔드포인트는 이미 목록에 있는 상태임을 전제한다.</li></ul></li><li><strong>동작</strong> 탭 > <strong>동작 생성</strong> 버튼 클릭, 랜딩 페이지의 경로들을 3-2번에서 추가한 랜딩 페이지 엔드포인트로 요청하도록 원본 지정<ul><li>대표적으로 <code>/</code> 경로에 대한 요청에 랜딩 페이지를 응답하게 되며,</li><li>동작으로 지정하지 않은 경로에 대한 요청은 기본값으로 처리되어 서비스 애플리케이션의 자원을 응답하게 된다.</li></ul></li></ol></li><li>앞서 얘기했던 모바일 애플리케이션의 요구사항을 반영하기 위한 CloudFront 함수를 작성한다.<ol><li>CloudFront > 사이드바에서 <strong>함수</strong> 선택 > <strong>함수 생성</strong> 버튼 클릭, 적절한 이름과 설명 입력</li><li><strong>빌드</strong> 탭 > <strong>개발</strong> 탭에서 JavaScript로 코드 작성 후 <strong>변경 사항 저장</strong> 버튼 클릭<ul><li>요청 헤더에 따라 302 코드를 갖는 redirect 응답을 반환하거나 요청을 그대로 반환하도록 작성했다.</li><li>WebView 요청 시 모바일 애플리케이션임을 구분할 수 있도록 요청 헤더를 이미 설정해둔 상태였다.</li><li><a href=https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#request-custom-headers-behavior>HTTP 요청 헤더 및 CloudFront 동작(사용자 지정 및 Amazon S3 오리진)</a>: CloudFront 함수에서 어떤 헤더 값을 지원하는지 확인했던 문서이다.</li><li><a href=https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/adding-cloudfront-headers.html#cloudfront-headers-device-type>최종 사용자의 디바이스 유형을 확인하기 위한 헤더</a>: 이런 것도 활용해볼 수 있을 것 같다.</li></ul></li><li><strong>게시</strong> 탭에서 <strong>함수 게시</strong> 버튼 클릭 (라이브 스테이지로 올리고 CloudFront 배포와 연결 준비)</li><li><strong>함수</strong> > <strong>게시</strong> 탭에서 배포를 선택해 배포 연결을 추가하거나 <strong>배포</strong> > <strong>동작</strong>을 선택해 편집 화면으로 들어가 <code>/</code> 경로에 대한 동작에 뷰어 요청으로 함수를 연결한다.<ul><li>뷰어 요청(Viewer request): CloudFront가 요청 받은 자원이 CloudFront 캐시에 있는지 확인하기 전에 실행할 함수</li><li>뷰어 응답(Viewer response): CloudFront가 요청 받은 자원을 응답하기 전에 실행할 함수</li><li>좀 더 자세한 설명은 <a href=https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-cloudfront-trigger-events.html>CloudFront events that can trigger a Lambda@Edge function</a> 참고</li></ul></li><li>참고: <strong>함수</strong> > <strong>테스트</strong> 탭에서 함수를 테스트해볼 수 있다.</li></ol></li></ol><p>이로써 랜딩 페이지의 자원을 요청하는 경로에 대해 랜딩 페이지를 응답하고, 서비스 애플리케이션의 자원을 요청하는 경로에 대해 서비스 애플리케이션을 응답해 하나의 도메인으로 두 개의 S3 웹사이트 엔드포인트를 호스팅할 수 있다.</p><h2 id=덧붙이는-생각>덧붙이는 생각</h2><p>첫 번째, 이 방법은 랜딩 페이지만 public 폴더에 리소스를 가지고 있기 때문에 활용할 수 있는 방법이었던 것 같다.<br>서비스 애플리케이션도 public 폴더에 리소스를 갖고 있었다면 정규 표현식으로 두 프로젝트의 리소스를 구분하거나 리소스 하나하나 동작으로 추가하는 지저분한 방법을 썼어야 했을지도..😖<br>(만약 그래야 했다면 다른 방법을 모색했을 것 같다.)</p><p>두 번째, 하나의 비즈니스 도메인으로서 어떤 형태의 인프라를 갖는지, 어떻게 관리하면 되는지에 대해 효과적으로 공유할 수 있는 방법이 있을까? 🤔<br>최근 Serverless REST API를 구현하기 위해 AWS Lambda 함수를 작성할 때도 비슷한 생각을 했는데 이번에 작성한 CloudFront Function 코드가 존재함을 명확하게 하고 형상 관리할 방법이 있을까 고민이다.<br>변경할 일이 없을 수도 있지만 그럼에도 불구하고 말이다. (GitHub가 최선일까?)</p></div><div class=post-footer></div></article></main></body></html>